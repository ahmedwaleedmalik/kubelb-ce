//
//Copyright 2025 The KubeLB Authors.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v5.29.3
// source: proto/tunnel/tunnel.proto

package tunnel

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type TunnelControl_Type int32

const (
	TunnelControl_PING       TunnelControl_Type = 0
	TunnelControl_PONG       TunnelControl_Type = 1
	TunnelControl_DISCONNECT TunnelControl_Type = 2
)

// Enum value maps for TunnelControl_Type.
var (
	TunnelControl_Type_name = map[int32]string{
		0: "PING",
		1: "PONG",
		2: "DISCONNECT",
	}
	TunnelControl_Type_value = map[string]int32{
		"PING":       0,
		"PONG":       1,
		"DISCONNECT": 2,
	}
)

func (x TunnelControl_Type) Enum() *TunnelControl_Type {
	p := new(TunnelControl_Type)
	*p = x
	return p
}

func (x TunnelControl_Type) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TunnelControl_Type) Descriptor() protoreflect.EnumDescriptor {
	return file_proto_tunnel_tunnel_proto_enumTypes[0].Descriptor()
}

func (TunnelControl_Type) Type() protoreflect.EnumType {
	return &file_proto_tunnel_tunnel_proto_enumTypes[0]
}

func (x TunnelControl_Type) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TunnelControl_Type.Descriptor instead.
func (TunnelControl_Type) EnumDescriptor() ([]byte, []int) {
	return file_proto_tunnel_tunnel_proto_rawDescGZIP(), []int{4, 0}
}

// TunnelMessage is the wrapper for all tunnel communication
type TunnelMessage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Payload:
	//
	//	*TunnelMessage_Auth
	//	*TunnelMessage_Request
	//	*TunnelMessage_Response
	//	*TunnelMessage_Control
	//	*TunnelMessage_Error
	Payload       isTunnelMessage_Payload `protobuf_oneof:"payload"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TunnelMessage) Reset() {
	*x = TunnelMessage{}
	mi := &file_proto_tunnel_tunnel_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TunnelMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TunnelMessage) ProtoMessage() {}

func (x *TunnelMessage) ProtoReflect() protoreflect.Message {
	mi := &file_proto_tunnel_tunnel_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TunnelMessage.ProtoReflect.Descriptor instead.
func (*TunnelMessage) Descriptor() ([]byte, []int) {
	return file_proto_tunnel_tunnel_proto_rawDescGZIP(), []int{0}
}

func (x *TunnelMessage) GetPayload() isTunnelMessage_Payload {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *TunnelMessage) GetAuth() *TunnelAuth {
	if x != nil {
		if x, ok := x.Payload.(*TunnelMessage_Auth); ok {
			return x.Auth
		}
	}
	return nil
}

func (x *TunnelMessage) GetRequest() *HttpRequest {
	if x != nil {
		if x, ok := x.Payload.(*TunnelMessage_Request); ok {
			return x.Request
		}
	}
	return nil
}

func (x *TunnelMessage) GetResponse() *HttpResponse {
	if x != nil {
		if x, ok := x.Payload.(*TunnelMessage_Response); ok {
			return x.Response
		}
	}
	return nil
}

func (x *TunnelMessage) GetControl() *TunnelControl {
	if x != nil {
		if x, ok := x.Payload.(*TunnelMessage_Control); ok {
			return x.Control
		}
	}
	return nil
}

func (x *TunnelMessage) GetError() *TunnelError {
	if x != nil {
		if x, ok := x.Payload.(*TunnelMessage_Error); ok {
			return x.Error
		}
	}
	return nil
}

type isTunnelMessage_Payload interface {
	isTunnelMessage_Payload()
}

type TunnelMessage_Auth struct {
	Auth *TunnelAuth `protobuf:"bytes,1,opt,name=auth,proto3,oneof"`
}

type TunnelMessage_Request struct {
	Request *HttpRequest `protobuf:"bytes,2,opt,name=request,proto3,oneof"`
}

type TunnelMessage_Response struct {
	Response *HttpResponse `protobuf:"bytes,3,opt,name=response,proto3,oneof"`
}

type TunnelMessage_Control struct {
	Control *TunnelControl `protobuf:"bytes,4,opt,name=control,proto3,oneof"`
}

type TunnelMessage_Error struct {
	Error *TunnelError `protobuf:"bytes,5,opt,name=error,proto3,oneof"`
}

func (*TunnelMessage_Auth) isTunnelMessage_Payload() {}

func (*TunnelMessage_Request) isTunnelMessage_Payload() {}

func (*TunnelMessage_Response) isTunnelMessage_Payload() {}

func (*TunnelMessage_Control) isTunnelMessage_Payload() {}

func (*TunnelMessage_Error) isTunnelMessage_Payload() {}

// TunnelAuth is sent by the client to authenticate the tunnel
type TunnelAuth struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Token         string                 `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`                             // Authentication token
	Hostname      string                 `protobuf:"bytes,2,opt,name=hostname,proto3" json:"hostname,omitempty"`                       // Hostname to tunnel (e.g., app1.wmx.dev)
	TargetPort    string                 `protobuf:"bytes,3,opt,name=target_port,json=targetPort,proto3" json:"target_port,omitempty"` // Local port to forward to
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TunnelAuth) Reset() {
	*x = TunnelAuth{}
	mi := &file_proto_tunnel_tunnel_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TunnelAuth) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TunnelAuth) ProtoMessage() {}

func (x *TunnelAuth) ProtoReflect() protoreflect.Message {
	mi := &file_proto_tunnel_tunnel_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TunnelAuth.ProtoReflect.Descriptor instead.
func (*TunnelAuth) Descriptor() ([]byte, []int) {
	return file_proto_tunnel_tunnel_proto_rawDescGZIP(), []int{1}
}

func (x *TunnelAuth) GetToken() string {
	if x != nil {
		return x.Token
	}
	return ""
}

func (x *TunnelAuth) GetHostname() string {
	if x != nil {
		return x.Hostname
	}
	return ""
}

func (x *TunnelAuth) GetTargetPort() string {
	if x != nil {
		return x.TargetPort
	}
	return ""
}

// HttpRequest represents an incoming HTTP request to be forwarded
type HttpRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RequestId     string                 `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`                                                      // Unique request identifier
	Method        string                 `protobuf:"bytes,2,opt,name=method,proto3" json:"method,omitempty"`                                                                             // HTTP method
	Path          string                 `protobuf:"bytes,3,opt,name=path,proto3" json:"path,omitempty"`                                                                                 // Request path
	Headers       map[string]string      `protobuf:"bytes,4,rep,name=headers,proto3" json:"headers,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // HTTP headers
	Body          []byte                 `protobuf:"bytes,5,opt,name=body,proto3" json:"body,omitempty"`                                                                                 // Request body
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HttpRequest) Reset() {
	*x = HttpRequest{}
	mi := &file_proto_tunnel_tunnel_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HttpRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HttpRequest) ProtoMessage() {}

func (x *HttpRequest) ProtoReflect() protoreflect.Message {
	mi := &file_proto_tunnel_tunnel_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HttpRequest.ProtoReflect.Descriptor instead.
func (*HttpRequest) Descriptor() ([]byte, []int) {
	return file_proto_tunnel_tunnel_proto_rawDescGZIP(), []int{2}
}

func (x *HttpRequest) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *HttpRequest) GetMethod() string {
	if x != nil {
		return x.Method
	}
	return ""
}

func (x *HttpRequest) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

func (x *HttpRequest) GetHeaders() map[string]string {
	if x != nil {
		return x.Headers
	}
	return nil
}

func (x *HttpRequest) GetBody() []byte {
	if x != nil {
		return x.Body
	}
	return nil
}

// HttpResponse represents the response from the local service
type HttpResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RequestId     string                 `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`                                                      // Matches the request ID
	StatusCode    int32                  `protobuf:"varint,2,opt,name=status_code,json=statusCode,proto3" json:"status_code,omitempty"`                                                  // HTTP status code
	Headers       map[string]string      `protobuf:"bytes,3,rep,name=headers,proto3" json:"headers,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // Response headers
	Body          []byte                 `protobuf:"bytes,4,opt,name=body,proto3" json:"body,omitempty"`                                                                                 // Response body
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HttpResponse) Reset() {
	*x = HttpResponse{}
	mi := &file_proto_tunnel_tunnel_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HttpResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HttpResponse) ProtoMessage() {}

func (x *HttpResponse) ProtoReflect() protoreflect.Message {
	mi := &file_proto_tunnel_tunnel_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HttpResponse.ProtoReflect.Descriptor instead.
func (*HttpResponse) Descriptor() ([]byte, []int) {
	return file_proto_tunnel_tunnel_proto_rawDescGZIP(), []int{3}
}

func (x *HttpResponse) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *HttpResponse) GetStatusCode() int32 {
	if x != nil {
		return x.StatusCode
	}
	return 0
}

func (x *HttpResponse) GetHeaders() map[string]string {
	if x != nil {
		return x.Headers
	}
	return nil
}

func (x *HttpResponse) GetBody() []byte {
	if x != nil {
		return x.Body
	}
	return nil
}

// TunnelControl handles control messages like ping/pong
type TunnelControl struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Type          TunnelControl_Type     `protobuf:"varint,1,opt,name=type,proto3,enum=tunnel.TunnelControl_Type" json:"type,omitempty"`
	Message       string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TunnelControl) Reset() {
	*x = TunnelControl{}
	mi := &file_proto_tunnel_tunnel_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TunnelControl) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TunnelControl) ProtoMessage() {}

func (x *TunnelControl) ProtoReflect() protoreflect.Message {
	mi := &file_proto_tunnel_tunnel_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TunnelControl.ProtoReflect.Descriptor instead.
func (*TunnelControl) Descriptor() ([]byte, []int) {
	return file_proto_tunnel_tunnel_proto_rawDescGZIP(), []int{4}
}

func (x *TunnelControl) GetType() TunnelControl_Type {
	if x != nil {
		return x.Type
	}
	return TunnelControl_PING
}

func (x *TunnelControl) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

// TunnelError represents an error in tunnel communication
type TunnelError struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RequestId     string                 `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`          // Request ID if applicable
	ErrorMessage  string                 `protobuf:"bytes,2,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"` // Error description
	ErrorCode     int32                  `protobuf:"varint,3,opt,name=error_code,json=errorCode,proto3" json:"error_code,omitempty"`         // Error code
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TunnelError) Reset() {
	*x = TunnelError{}
	mi := &file_proto_tunnel_tunnel_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TunnelError) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TunnelError) ProtoMessage() {}

func (x *TunnelError) ProtoReflect() protoreflect.Message {
	mi := &file_proto_tunnel_tunnel_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TunnelError.ProtoReflect.Descriptor instead.
func (*TunnelError) Descriptor() ([]byte, []int) {
	return file_proto_tunnel_tunnel_proto_rawDescGZIP(), []int{5}
}

func (x *TunnelError) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *TunnelError) GetErrorMessage() string {
	if x != nil {
		return x.ErrorMessage
	}
	return ""
}

func (x *TunnelError) GetErrorCode() int32 {
	if x != nil {
		return x.ErrorCode
	}
	return 0
}

// HealthRequest is empty
type HealthRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HealthRequest) Reset() {
	*x = HealthRequest{}
	mi := &file_proto_tunnel_tunnel_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HealthRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HealthRequest) ProtoMessage() {}

func (x *HealthRequest) ProtoReflect() protoreflect.Message {
	mi := &file_proto_tunnel_tunnel_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HealthRequest.ProtoReflect.Descriptor instead.
func (*HealthRequest) Descriptor() ([]byte, []int) {
	return file_proto_tunnel_tunnel_proto_rawDescGZIP(), []int{6}
}

// HealthResponse indicates service health
type HealthResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Healthy       bool                   `protobuf:"varint,1,opt,name=healthy,proto3" json:"healthy,omitempty"`
	Message       string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HealthResponse) Reset() {
	*x = HealthResponse{}
	mi := &file_proto_tunnel_tunnel_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HealthResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HealthResponse) ProtoMessage() {}

func (x *HealthResponse) ProtoReflect() protoreflect.Message {
	mi := &file_proto_tunnel_tunnel_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HealthResponse.ProtoReflect.Descriptor instead.
func (*HealthResponse) Descriptor() ([]byte, []int) {
	return file_proto_tunnel_tunnel_proto_rawDescGZIP(), []int{7}
}

func (x *HealthResponse) GetHealthy() bool {
	if x != nil {
		return x.Healthy
	}
	return false
}

func (x *HealthResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

// ForwardRequestMessage is sent by Envoy to forward an HTTP request
type ForwardRequestMessage struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TunnelHost    string                 `protobuf:"bytes,1,opt,name=tunnel_host,json=tunnelHost,proto3" json:"tunnel_host,omitempty"`    // Target tunnel hostname (e.g., app1.wmx.dev)
	TunnelToken   string                 `protobuf:"bytes,2,opt,name=tunnel_token,json=tunnelToken,proto3" json:"tunnel_token,omitempty"` // Authentication token
	Request       *HttpRequest           `protobuf:"bytes,3,opt,name=request,proto3" json:"request,omitempty"`                            // The HTTP request to forward
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ForwardRequestMessage) Reset() {
	*x = ForwardRequestMessage{}
	mi := &file_proto_tunnel_tunnel_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ForwardRequestMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ForwardRequestMessage) ProtoMessage() {}

func (x *ForwardRequestMessage) ProtoReflect() protoreflect.Message {
	mi := &file_proto_tunnel_tunnel_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ForwardRequestMessage.ProtoReflect.Descriptor instead.
func (*ForwardRequestMessage) Descriptor() ([]byte, []int) {
	return file_proto_tunnel_tunnel_proto_rawDescGZIP(), []int{8}
}

func (x *ForwardRequestMessage) GetTunnelHost() string {
	if x != nil {
		return x.TunnelHost
	}
	return ""
}

func (x *ForwardRequestMessage) GetTunnelToken() string {
	if x != nil {
		return x.TunnelToken
	}
	return ""
}

func (x *ForwardRequestMessage) GetRequest() *HttpRequest {
	if x != nil {
		return x.Request
	}
	return nil
}

// ForwardResponseMessage contains the response from the tunnel
type ForwardResponseMessage struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Response      *HttpResponse          `protobuf:"bytes,1,opt,name=response,proto3" json:"response,omitempty"` // The HTTP response from the tunnel
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ForwardResponseMessage) Reset() {
	*x = ForwardResponseMessage{}
	mi := &file_proto_tunnel_tunnel_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ForwardResponseMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ForwardResponseMessage) ProtoMessage() {}

func (x *ForwardResponseMessage) ProtoReflect() protoreflect.Message {
	mi := &file_proto_tunnel_tunnel_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ForwardResponseMessage.ProtoReflect.Descriptor instead.
func (*ForwardResponseMessage) Descriptor() ([]byte, []int) {
	return file_proto_tunnel_tunnel_proto_rawDescGZIP(), []int{9}
}

func (x *ForwardResponseMessage) GetResponse() *HttpResponse {
	if x != nil {
		return x.Response
	}
	return nil
}

var File_proto_tunnel_tunnel_proto protoreflect.FileDescriptor

const file_proto_tunnel_tunnel_proto_rawDesc = "" +
	"\n" +
	"\x19proto/tunnel/tunnel.proto\x12\x06tunnel\"\x89\x02\n" +
	"\rTunnelMessage\x12(\n" +
	"\x04auth\x18\x01 \x01(\v2\x12.tunnel.TunnelAuthH\x00R\x04auth\x12/\n" +
	"\arequest\x18\x02 \x01(\v2\x13.tunnel.HttpRequestH\x00R\arequest\x122\n" +
	"\bresponse\x18\x03 \x01(\v2\x14.tunnel.HttpResponseH\x00R\bresponse\x121\n" +
	"\acontrol\x18\x04 \x01(\v2\x15.tunnel.TunnelControlH\x00R\acontrol\x12+\n" +
	"\x05error\x18\x05 \x01(\v2\x13.tunnel.TunnelErrorH\x00R\x05errorB\t\n" +
	"\apayload\"_\n" +
	"\n" +
	"TunnelAuth\x12\x14\n" +
	"\x05token\x18\x01 \x01(\tR\x05token\x12\x1a\n" +
	"\bhostname\x18\x02 \x01(\tR\bhostname\x12\x1f\n" +
	"\vtarget_port\x18\x03 \x01(\tR\n" +
	"targetPort\"\xe4\x01\n" +
	"\vHttpRequest\x12\x1d\n" +
	"\n" +
	"request_id\x18\x01 \x01(\tR\trequestId\x12\x16\n" +
	"\x06method\x18\x02 \x01(\tR\x06method\x12\x12\n" +
	"\x04path\x18\x03 \x01(\tR\x04path\x12:\n" +
	"\aheaders\x18\x04 \x03(\v2 .tunnel.HttpRequest.HeadersEntryR\aheaders\x12\x12\n" +
	"\x04body\x18\x05 \x01(\fR\x04body\x1a:\n" +
	"\fHeadersEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xdb\x01\n" +
	"\fHttpResponse\x12\x1d\n" +
	"\n" +
	"request_id\x18\x01 \x01(\tR\trequestId\x12\x1f\n" +
	"\vstatus_code\x18\x02 \x01(\x05R\n" +
	"statusCode\x12;\n" +
	"\aheaders\x18\x03 \x03(\v2!.tunnel.HttpResponse.HeadersEntryR\aheaders\x12\x12\n" +
	"\x04body\x18\x04 \x01(\fR\x04body\x1a:\n" +
	"\fHeadersEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\x85\x01\n" +
	"\rTunnelControl\x12.\n" +
	"\x04type\x18\x01 \x01(\x0e2\x1a.tunnel.TunnelControl.TypeR\x04type\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\"*\n" +
	"\x04Type\x12\b\n" +
	"\x04PING\x10\x00\x12\b\n" +
	"\x04PONG\x10\x01\x12\x0e\n" +
	"\n" +
	"DISCONNECT\x10\x02\"p\n" +
	"\vTunnelError\x12\x1d\n" +
	"\n" +
	"request_id\x18\x01 \x01(\tR\trequestId\x12#\n" +
	"\rerror_message\x18\x02 \x01(\tR\ferrorMessage\x12\x1d\n" +
	"\n" +
	"error_code\x18\x03 \x01(\x05R\terrorCode\"\x0f\n" +
	"\rHealthRequest\"D\n" +
	"\x0eHealthResponse\x12\x18\n" +
	"\ahealthy\x18\x01 \x01(\bR\ahealthy\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\"\x8a\x01\n" +
	"\x15ForwardRequestMessage\x12\x1f\n" +
	"\vtunnel_host\x18\x01 \x01(\tR\n" +
	"tunnelHost\x12!\n" +
	"\ftunnel_token\x18\x02 \x01(\tR\vtunnelToken\x12-\n" +
	"\arequest\x18\x03 \x01(\v2\x13.tunnel.HttpRequestR\arequest\"J\n" +
	"\x16ForwardResponseMessage\x120\n" +
	"\bresponse\x18\x01 \x01(\v2\x14.tunnel.HttpResponseR\bresponse2\xdb\x01\n" +
	"\rTunnelService\x12@\n" +
	"\fCreateTunnel\x12\x15.tunnel.TunnelMessage\x1a\x15.tunnel.TunnelMessage(\x010\x01\x12O\n" +
	"\x0eForwardRequest\x12\x1d.tunnel.ForwardRequestMessage\x1a\x1e.tunnel.ForwardResponseMessage\x127\n" +
	"\x06Health\x12\x15.tunnel.HealthRequest\x1a\x16.tunnel.HealthResponseB\x1cZ\x1ak8c.io/kubelb/proto/tunnelb\x06proto3"

var (
	file_proto_tunnel_tunnel_proto_rawDescOnce sync.Once
	file_proto_tunnel_tunnel_proto_rawDescData []byte
)

func file_proto_tunnel_tunnel_proto_rawDescGZIP() []byte {
	file_proto_tunnel_tunnel_proto_rawDescOnce.Do(func() {
		file_proto_tunnel_tunnel_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_proto_tunnel_tunnel_proto_rawDesc), len(file_proto_tunnel_tunnel_proto_rawDesc)))
	})
	return file_proto_tunnel_tunnel_proto_rawDescData
}

var file_proto_tunnel_tunnel_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_proto_tunnel_tunnel_proto_msgTypes = make([]protoimpl.MessageInfo, 12)
var file_proto_tunnel_tunnel_proto_goTypes = []any{
	(TunnelControl_Type)(0),        // 0: tunnel.TunnelControl.Type
	(*TunnelMessage)(nil),          // 1: tunnel.TunnelMessage
	(*TunnelAuth)(nil),             // 2: tunnel.TunnelAuth
	(*HttpRequest)(nil),            // 3: tunnel.HttpRequest
	(*HttpResponse)(nil),           // 4: tunnel.HttpResponse
	(*TunnelControl)(nil),          // 5: tunnel.TunnelControl
	(*TunnelError)(nil),            // 6: tunnel.TunnelError
	(*HealthRequest)(nil),          // 7: tunnel.HealthRequest
	(*HealthResponse)(nil),         // 8: tunnel.HealthResponse
	(*ForwardRequestMessage)(nil),  // 9: tunnel.ForwardRequestMessage
	(*ForwardResponseMessage)(nil), // 10: tunnel.ForwardResponseMessage
	nil,                            // 11: tunnel.HttpRequest.HeadersEntry
	nil,                            // 12: tunnel.HttpResponse.HeadersEntry
}
var file_proto_tunnel_tunnel_proto_depIdxs = []int32{
	2,  // 0: tunnel.TunnelMessage.auth:type_name -> tunnel.TunnelAuth
	3,  // 1: tunnel.TunnelMessage.request:type_name -> tunnel.HttpRequest
	4,  // 2: tunnel.TunnelMessage.response:type_name -> tunnel.HttpResponse
	5,  // 3: tunnel.TunnelMessage.control:type_name -> tunnel.TunnelControl
	6,  // 4: tunnel.TunnelMessage.error:type_name -> tunnel.TunnelError
	11, // 5: tunnel.HttpRequest.headers:type_name -> tunnel.HttpRequest.HeadersEntry
	12, // 6: tunnel.HttpResponse.headers:type_name -> tunnel.HttpResponse.HeadersEntry
	0,  // 7: tunnel.TunnelControl.type:type_name -> tunnel.TunnelControl.Type
	3,  // 8: tunnel.ForwardRequestMessage.request:type_name -> tunnel.HttpRequest
	4,  // 9: tunnel.ForwardResponseMessage.response:type_name -> tunnel.HttpResponse
	1,  // 10: tunnel.TunnelService.CreateTunnel:input_type -> tunnel.TunnelMessage
	9,  // 11: tunnel.TunnelService.ForwardRequest:input_type -> tunnel.ForwardRequestMessage
	7,  // 12: tunnel.TunnelService.Health:input_type -> tunnel.HealthRequest
	1,  // 13: tunnel.TunnelService.CreateTunnel:output_type -> tunnel.TunnelMessage
	10, // 14: tunnel.TunnelService.ForwardRequest:output_type -> tunnel.ForwardResponseMessage
	8,  // 15: tunnel.TunnelService.Health:output_type -> tunnel.HealthResponse
	13, // [13:16] is the sub-list for method output_type
	10, // [10:13] is the sub-list for method input_type
	10, // [10:10] is the sub-list for extension type_name
	10, // [10:10] is the sub-list for extension extendee
	0,  // [0:10] is the sub-list for field type_name
}

func init() { file_proto_tunnel_tunnel_proto_init() }
func file_proto_tunnel_tunnel_proto_init() {
	if File_proto_tunnel_tunnel_proto != nil {
		return
	}
	file_proto_tunnel_tunnel_proto_msgTypes[0].OneofWrappers = []any{
		(*TunnelMessage_Auth)(nil),
		(*TunnelMessage_Request)(nil),
		(*TunnelMessage_Response)(nil),
		(*TunnelMessage_Control)(nil),
		(*TunnelMessage_Error)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_proto_tunnel_tunnel_proto_rawDesc), len(file_proto_tunnel_tunnel_proto_rawDesc)),
			NumEnums:      1,
			NumMessages:   12,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_proto_tunnel_tunnel_proto_goTypes,
		DependencyIndexes: file_proto_tunnel_tunnel_proto_depIdxs,
		EnumInfos:         file_proto_tunnel_tunnel_proto_enumTypes,
		MessageInfos:      file_proto_tunnel_tunnel_proto_msgTypes,
	}.Build()
	File_proto_tunnel_tunnel_proto = out.File
	file_proto_tunnel_tunnel_proto_goTypes = nil
	file_proto_tunnel_tunnel_proto_depIdxs = nil
}
